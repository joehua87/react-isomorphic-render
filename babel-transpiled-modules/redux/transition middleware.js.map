{"version":3,"sources":["../../source/redux/transition middleware.js"],"names":[],"mappings":";;;;;;uCAAkC,4BAA4B;;;AAG9D,IAAM,qBAAqB,GAAG,SAAxB,qBAAqB,CAAI,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAC/E;KADiF,OAAO,yDAAG,EAAE;;AAE5F,KAAM,WAAW,GAAG,OAAO,CAAC,QAAQ,GAAG,kBAAkB,GAAG,SAAS,CAAA;;AAErE,QAAO,UAAU,CACf,MAAM,CAAC,UAAA,SAAS;SAAI,SAAS,CAAC,WAAW,CAAC;EAAA,CAAC;EAC3C,GAAG,CAAC,UAAA,SAAS;SAAI,SAAS,CAAC,WAAW,CAAC;EAAA,CAAC;EACxC,GAAG,CAAC,UAAA,OAAO;SAAI,OAAO,CAAC,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,CAAC;EAAA,CAAC,CAAA;CAC/D,CAAA;;AAED,IAAM,mBAAmB,GAAG,SAAtB,mBAAmB,CAAI,CAAC,EAAE,CAAC;QAAK,AAAC,CAAC,CAAC,QAAQ,KAAK,CAAC,CAAC,QAAQ,IAAM,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,MAAM,AAAC;CAAA,CAAA;;qBAE7E,UAAS,MAAM,EAC9B;AACC,QAAO,UAAC,IAAsB;MAApB,QAAQ,GAAV,IAAsB,CAApB,QAAQ;MAAE,QAAQ,GAApB,IAAsB,CAAV,QAAQ;SAAO,UAAA,IAAI;UAAI,UAAA,MAAM,EACjD;;AAEC,QAAI,MAAM,CAAC,IAAI,+CAAsB,EACrC;;AAEC,YAAO,IAAI,CAAC,MAAM,CAAC,CAAA;KACnB;;;AAGD,QAAI,QAAQ,EAAE,CAAC,MAAM,IAAI,mBAAmB,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,MAAM,CAAC,QAAQ,CAAC,EACjG;AACC,YAAO,IAAI,CAAC,MAAM,CAAC,CAAA;KACnB;;0BAEwC,MAAM,CAAC,OAAO;QAA/C,UAAU,mBAAV,UAAU;QAAE,QAAQ,mBAAR,QAAQ;QAAE,MAAM,mBAAN,MAAM;;AAEpC,QAAM,OAAO,GAAG,aAAY,UAAA,OAAO,EACnC;;AAEC,cAAQ,GAAG,CAAC,qBAAqB,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,CAAC,CAAC;;cAE9E,CAAC,UAAA,KAAK;aAAI,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC;MAAA,CAAC;;MAEnD,IAAI,CAAC,YACN;;AAEC,UAAI,CAAC,MAAM,CAAC,CAAA;;AAEZ,eAAQ,GAAG,CAAC,qBAAqB,CAAC,UAAU,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC,CAAC;;eAElG,CAAC,UAAA,KAAK;cAAI,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,KAAK,IAAI,KAAK,CAAC;OAAA,CAAC;;OAEnD,IAAI,CAAC,OAAO,CAAC,CAAA;MACd,CAAC,CAAA;KACF,CAAC,CAAA;;AAEF,QAAI,MAAM,EACV;;;;AAIC,aAAQ,EAAE,CAAC,MAAM,GAAG,OAAO,CAAA;KAC3B;;;;;;AAMD,WAAO,OAAO,CAAA;IACd;GAAA;EAAA,CAAA;CACD","file":"transition middleware.js","sourcesContent":["import { ROUTER_DID_CHANGE } from 'redux-router/lib/constants'\n\n// returns a promise which resolves when all the required preload()s are resolved\nconst get_data_dependencies = (components, getState, dispatch, location, params, options = {}) =>\n{\n\tconst method_name = options.deferred ? 'preload_deferred' : 'preload'\n\n\treturn components\n\t\t.filter(component => component[method_name]) // only look at ones with a static preload()\n\t\t.map(component => component[method_name])    // pull out fetch data methods\n\t\t.map(preload => preload(dispatch, getState, location, params))  // call fetch data methods and save promises\n}\n\nconst locations_are_equal = (a, b) => (a.pathname === b.pathname) && (a.search === b.search)\n\nexport default function(server)\n{\n\treturn ({ getState, dispatch }) => next => action =>\n\t{\n\t\t// on navigation\n\t\tif (action.type !== ROUTER_DID_CHANGE)\n\t\t{\n\t\t\t// proceed\n\t\t\treturn next(action)\n\t\t}\n\n\t\t// do nothing if it's taking place on the client and the location hasn't changed\n\t\tif (getState().router && locations_are_equal(action.payload.location, getState().router.location))\n\t\t{\n\t\t\treturn next(action)\n\t\t}\n\n\t\tconst { components, location, params } = action.payload\n\n\t\tconst promise = new Promise(resolve =>\n\t\t{\n\t\t\t// preload all the required data\n\t\t\tPromise.all(get_data_dependencies(components, getState, dispatch, location, params))\n\t\t\t// check for errors\n\t\t\t.catch(error => console.error(error.stack || error))\n\t\t\t// then\n\t\t\t.then(() =>\n\t\t\t{\n\t\t\t\t// proceed\n\t\t\t\tnext(action)\n\t\t\t\t// preload all the deferred required data (if any)\n\t\t\t\tPromise.all(get_data_dependencies(components, getState, dispatch, location, params, { deferred: true }))\n\t\t\t\t// check for errors\n\t\t\t\t.catch(error => console.error(error.stack || error))\n\t\t\t\t// done\n\t\t\t\t.then(resolve)\n\t\t\t})\n\t\t})\n\n\t\tif (server)\n\t\t{\n\t\t\t// router state is null until ReduxRouter is created (on the client) \n\t\t\t// so we can use router state variable to store the promise \n\t\t\t// to let the server know when it can render\n\t\t\tgetState().router = promise\n\t\t}\n\n\t\t// preload() then proceed\n\t\t//\n\t\t// returning promise from a middleware is not required.\n\t\t// can be used like: store.dispatch({ ... }).then(...)\n\t\treturn promise\n\t}\n}"]}