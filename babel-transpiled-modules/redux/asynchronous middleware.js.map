{"version":3,"sources":["../../source/redux/asynchronous middleware.js"],"names":[],"mappings":";;;;;;;;;;qBACwB,UAAU;;AAAnB,SAAS,UAAU,CAAC,WAAW,EAC9C;AACC,QAAO,UAAC,IAAsB,EAC9B;MADU,QAAQ,GAAV,IAAsB,CAApB,QAAQ;MAAE,QAAQ,GAApB,IAAsB,CAAV,QAAQ;;AAE3B,SAAO,UAAA,IAAI;UAAI,UAAA,MAAM,EACrB;AACC,QAAI,OAAO,MAAM,KAAK,UAAU,EAChC;;AAEC,YAAO,MAAM,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAA;KACjC;;QAEO,OAAO,GAAsB,MAAM,CAAnC,OAAO;QAAE,MAAM,GAAc,MAAM,CAA1B,MAAM;;QAAK,IAAI,4BAAK,MAAM;;AAE3C,QAAI,CAAC,OAAO,EACZ;AACC,YAAO,IAAI,CAAC,MAAM,CAAC,CAAA;KACnB;;;QAGM,OAAO,GAAsB,MAAM;QAA1B,OAAO,GAAa,MAAM;QAAjB,OAAO,GAAI,MAAM;;;AAG1C,QAAI,cAAM,IAAI,IAAE,IAAI,EAAE,OAAO,IAAG,CAAA;;;;;;;;;;;;;;;;;;;;;;AAsBhC,WAAO,aAAY,UAAC,OAAO,EAAE,MAAM,EACnC;AACC,YAAO,CAAC,WAAW,CAAC,CAAC,IAAI,CAExB,UAAA,MAAM,EACN;AACC,UAAI,cAAM,IAAI,IAAE,MAAM,EAAN,MAAM,EAAE,IAAI,EAAE,OAAO,IAAG,CAAA;AACxC,aAAO,CAAC,MAAM,CAAC,CAAA;MACf,EACD,UAAA,KAAK,EACL;AACC,UAAI,cAAM,IAAI,IAAE,KAAK,EAAL,KAAK,EAAG,IAAI,EAAE,OAAO,IAAG,CAAA;AACxC,YAAM,CAAC,KAAK,CAAC,CAAA;MACb,CACD,CAAA;KACD,CAAC,CAAA;IACF;GAAA,CAAA;EACD,CAAA;CACD","file":"asynchronous middleware.js","sourcesContent":["// сработает при вызове dispatch({ promise: ... })\nexport default function middleware(http_client)\n{\n\treturn ({ dispatch, getState }) =>\n\t{\n\t\treturn next => action =>\n\t\t{\n\t\t\tif (typeof action === 'function')\n\t\t\t{\n\t\t\t\t// or maybe: next(action)\n\t\t\t\treturn action(dispatch, getState)\n\t\t\t}\n\n\t\t\tconst { promise, events, ...rest } = action\n\n\t\t\tif (!promise)\n\t\t\t{\n\t\t\t\treturn next(action)\n\t\t\t}\n\n\t\t\t// event names\n\t\t\tconst [Request, Success, Failure] = events\n\n\t\t\t// start asynchronous request\n\t\t\tnext({ ...rest, type: Request })\n\n\t\t\t// returning promise from a middleware is not required.\n\t\t\t//\n\t\t\t// can be used like: this.props.dispatch(action()).then(...)\n\t\t\t//\n\t\t\t// or most likely as: this.props.bound_action().then(...)\n\t\t\t//\n\t\t\t// or even most likely as:\n\t\t\t//\n\t\t\t// async do_something()\n\t\t\t// {\n\t\t\t// \ttry\n\t\t\t// \t{\n\t\t\t// \t\tconst result = await this.props.bound_action({ ... })\n\t\t\t// \t}\n\t\t\t// \tcatch (error)\n\t\t\t// \t{\n\t\t\t// \t\talert(error.status)\n\t\t\t// \t}\n\t\t\t// }\n\t\t\t//\n\t\t\treturn new Promise((resolve, reject) =>\n\t\t\t{\n\t\t\t\tpromise(http_client).then\n\t\t\t\t(\n\t\t\t\t\tresult =>\n\t\t\t\t\t{\n\t\t\t\t\t\tnext({ ...rest, result, type: Success })\n\t\t\t\t\t\tresolve(result)\n\t\t\t\t\t},\n\t\t\t\t\terror =>\n\t\t\t\t\t{\n\t\t\t\t\t\tnext({ ...rest, error,  type: Failure })\n\t\t\t\t\t\treject(error)\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t})\n\t\t}\n\t}\n}"]}